// Generated by purs version 0.13.3
"use strict";
var Control_Category = require("../Control.Category/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_CommutativeRing = require("../Data.CommutativeRing/index.js");
var Data_Complex = require("../Data.Complex/index.js");
var Data_DivisionRing = require("../Data.DivisionRing/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_FoldableWithIndex = require("../Data.FoldableWithIndex/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_Map_Internal = require("../Data.Map.Internal/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Ratio = require("../Data.Ratio/index.js");
var Data_Ring = require("../Data.Ring/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var $$Math = require("../Math/index.js");
var Poly = (function () {
    function Poly(value0) {
        this.value0 = value0;
    };
    Poly.create = function (value0) {
        return new Poly(value0);
    };
    return Poly;
})();
var IntLiftable = function (fromInt) {
    this.fromInt = fromInt;
};
var sortedMonoms = function (v) {
    return Data_Array.sortBy(function (v1) {
        return function (v3) {
            return Data_Ord.compare(Data_Ord.ordInt)(v3.value0)(v1.value0);
        };
    })(Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.value0));
};
var showPoly = function (dictShow) {
    return new Data_Show.Show(function (p) {
        return "{fromTuples " + (Data_Foldable.foldr(Data_Foldable.foldableArray)(Data_Semigroup.append(Data_Semigroup.semigroupString))("")(Data_Functor.map(Data_Functor.functorArray)(Data_Show.show(Data_Tuple.showTuple(Data_Show.showInt)(dictShow)))(sortedMonoms(p))) + "}");
    });
};
var semiringPoly = function (dictEq) {
    return function (dictSemiring) {
        return new Data_Semiring.Semiring(function (v) {
            return function (v1) {
                return Poly.create(Data_Map_Internal.filter(Data_Ord.ordInt)(function (v2) {
                    return Data_Eq.notEq(dictEq)(v2)(Data_Semiring.zero(dictSemiring));
                })(Data_Map_Internal.unionWith(Data_Ord.ordInt)(Data_Semiring.add(dictSemiring))(v.value0)(v1.value0)));
            };
        }, function (v) {
            return function (v1) {
                return Poly.create(Data_Map_Internal.filter(Data_Ord.ordInt)(function (v2) {
                    return Data_Eq.notEq(dictEq)(v2)(Data_Semiring.zero(dictSemiring));
                })(Data_Foldable.foldr(Data_Foldable.foldableArray)(Data_Map_Internal.unionWith(Data_Ord.ordInt)(Data_Semiring.add(dictSemiring)))(Data_Map_Internal.empty)(Data_Functor.map(Data_Functor.functorArray)(function (v2) {
                    return Data_FoldableWithIndex.foldrWithIndex(Data_Map_Internal.foldableWithIndexMap)(function (j) {
                        return function (w) {
                            return function (acc) {
                                return Data_Map_Internal.insert(Data_Ord.ordInt)(v2.value0 + j | 0)(Data_Semiring.mul(dictSemiring)(v2.value1)(w))(acc);
                            };
                        };
                    })(Data_Map_Internal.empty)(v1.value0);
                })(Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.value0)))));
            };
        }, Poly.create(Data_Map_Internal.singleton(0)(Data_Semiring.one(dictSemiring))), new Poly(Data_Map_Internal.empty));
    };
};
var semigroupPoly = new Data_Semigroup.Semigroup(function (v) {
    return function (v1) {
        return Poly.create(Data_Map_Internal.union(Data_Ord.ordInt)(v.value0)(v1.value0));
    };
});
var query = function (dictSemiring) {
    return function (v) {
        return function (n) {
            return Data_Maybe.fromMaybe(Data_Semiring.zero(dictSemiring))(Data_Map_Internal.lookup(Data_Ord.ordInt)(n)(v.value0));
        };
    };
};
var pow = function (dictSemiring) {
    return function (x) {
        return function (v) {
            if (v === 0) {
                return Data_Semiring.one(dictSemiring);
            };
            return Data_Semiring.mul(dictSemiring)(x)(pow(dictSemiring)(x)(v - 1 | 0));
        };
    };
};
var numberIntLiftable = new IntLiftable(Data_Int.toNumber);
var monoPol = function (x) {
    return function (n) {
        return Poly.create(Data_Map_Internal.insert(Data_Ord.ordInt)(n)(x)(Data_Map_Internal.empty));
    };
};
var intIntLiftable = new IntLiftable(Control_Category.identity(Control_Category.categoryFn));
var functorPoly = new Data_Functor.Functor(function (f) {
    return function (v) {
        return Poly.create(Data_Map_Internal.mapMaybe(Data_Ord.ordInt)(function (v1) {
            return Data_Maybe.Just.create(f(v1));
        })(v.value0));
    };
});
var liftC = function (p) {
    return Data_Functor.map(functorPoly)(function (v) {
        return Data_Functor.map(Data_Complex.functorCartesian)(function (v1) {
            return v1 * v;
        })(Data_Semiring.one(Data_Complex.semiringCartesian(Data_Ring.ringNumber)));
    })(p);
};
var ringPoly = function (dictEq) {
    return function (dictSemiring) {
        return function (dictRing) {
            return new Data_Ring.Ring(function () {
                return semiringPoly(dictEq)(dictRing.Semiring0());
            }, function (p1) {
                return function (p2) {
                    return Data_Semiring.add(semiringPoly(dictEq)(dictRing.Semiring0()))(p1)(Data_Functor.map(functorPoly)(function (v) {
                        return Data_Semiring.mul(dictRing.Semiring0())(v)(Data_Ring.negate(dictRing)(Data_Semiring.one(dictRing.Semiring0())));
                    })(p2));
                };
            });
        };
    };
};
var fromInt = function (dict) {
    return dict.fromInt;
};
var ratioIntLiftable = function (dictOrd) {
    return function (dictIntLiftable) {
        return function (dictEuclideanRing) {
            return new IntLiftable(function (n) {
                return Data_Ratio.reduce(dictOrd)(dictEuclideanRing)(fromInt(dictIntLiftable)(n))(Data_Semiring.one(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()));
            });
        };
    };
};
var eqPoly = function (dictEq) {
    return new Data_Eq.Eq(function (v) {
        return function (v1) {
            return Data_Eq.eq(Data_Map_Internal.eqMap(Data_Eq.eqInt)(dictEq))(v.value0)(v1.value0);
        };
    });
};
var ordPoly = function (dictOrd) {
    return function (dictEq) {
        return function (dictCommutativeRing) {
            return new Data_Ord.Ord(function () {
                return eqPoly(dictEq);
            }, function (p) {
                return function (q) {
                    var sq = sortedMonoms(q);
                    var sp = sortedMonoms(p);
                    var f = function ($copy_xs) {
                        return function ($copy_ys) {
                            var $tco_var_xs = $copy_xs;
                            var $tco_done = false;
                            var $tco_result;
                            function $tco_loop(xs, ys) {
                                var v = Data_Array.uncons(xs);
                                if (v instanceof Data_Maybe.Just) {
                                    var v1 = Data_Array.uncons(ys);
                                    if (v1 instanceof Data_Maybe.Just) {
                                        if (v.value0.head.value0 !== v1.value0.head.value0) {
                                            $tco_done = true;
                                            return Data_Ord.compare(Data_Ord.ordInt)(v.value0.head.value0)(v1.value0.head.value0);
                                        };
                                        if (Data_Eq.notEq(dictEq)(v.value0.head.value1)(v1.value0.head.value1)) {
                                            $tco_done = true;
                                            return Data_Ord.compare(dictOrd)(v.value0.head.value1)(v1.value0.head.value1);
                                        };
                                        if (Data_Boolean.otherwise) {
                                            $tco_var_xs = v.value0.tail;
                                            $copy_ys = v1.value0.tail;
                                            return;
                                        };
                                        throw new Error("Failed pattern match at Data.Sparse.Polynomial (line 282, column 17 - line 285, column 46): " + [ Data_Unit.unit.constructor.name ]);
                                    };
                                    $tco_done = true;
                                    return Data_Ordering.GT.value;
                                };
                                var v1 = Data_Array.uncons(ys);
                                if (v1 instanceof Data_Maybe.Just) {
                                    $tco_done = true;
                                    return Data_Ordering.LT.value;
                                };
                                $tco_done = true;
                                return Data_Ordering.EQ.value;
                            };
                            while (!$tco_done) {
                                $tco_result = $tco_loop($tco_var_xs, $copy_ys);
                            };
                            return $tco_result;
                        };
                    };
                    return f(sp)(sq);
                };
            });
        };
    };
};
var dominantMonom = function (dictEq) {
    return function (dictSemiring) {
        return function (p) {
            var ordered = sortedMonoms(p);
            var v = Data_Array.uncons(ordered);
            if (v instanceof Data_Maybe.Just) {
                return v.value0.head;
            };
            return new Data_Tuple.Tuple(0, Data_Semiring.zero(dictSemiring));
        };
    };
};
var derivative = function (dictEq) {
    return function (dictSemiring) {
        return function (fromInt1) {
            return function (v) {
                var deriveMonom = function (v1) {
                    return function (v2) {
                        if (v1 === 0) {
                            return Data_Maybe.Nothing.value;
                        };
                        if (Data_Eq.eq(dictEq)(v2)(Data_Semiring.zero(dictSemiring))) {
                            return Data_Maybe.Nothing.value;
                        };
                        return Data_Maybe.Just.create(new Data_Tuple.Tuple(v1 - 1 | 0, Data_Semiring.mul(dictSemiring)(v2)(fromInt1(v1))));
                    };
                };
                return Poly.create(Data_Map_Internal.fromFoldable(Data_Ord.ordInt)(Data_Foldable.foldableArray)(Data_Array.catMaybes(Data_Functor.map(Data_Functor.functorArray)(Data_Tuple.uncurry(deriveMonom))(Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.value0)))));
            };
        };
    };
};
var diff = function (dictEq) {
    return function (dictOrd) {
        return function (dictSemiring) {
            return function (dictEuclideanRing) {
                return function (dictIntLiftable) {
                    return derivative(dictEq)(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(fromInt(dictIntLiftable));
                };
            };
        };
    };
};
var complexIntLiftable = function (dictSemiring) {
    return function (dictRing) {
        return function (dictIntLiftable) {
            return new IntLiftable(function (n) {
                return Data_Functor.map(Data_Complex.functorCartesian)(function (v) {
                    return Data_Semiring.mul(dictRing.Semiring0())(v)(fromInt(dictIntLiftable)(n));
                })(Data_Semiring.one(Data_Complex.semiringCartesian(dictRing)));
            });
        };
    };
};
var commutativeRingPoly = function (dictEq) {
    return function (dictCommutativeRing) {
        return new Data_CommutativeRing.CommutativeRing(function () {
            return ringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0())(dictCommutativeRing.Ring0());
        });
    };
};
var euclideanRingPoly = function (dictEq) {
    return function (dictDivisionRing) {
        return function (dictCommutativeRing) {
            return new Data_EuclideanRing.EuclideanRing(function () {
                return commutativeRingPoly(dictEq)(dictCommutativeRing);
            }, function (p) {
                var $140 = dominantMonom(dictEq)((dictCommutativeRing.Ring0()).Semiring0())(p);
                return $140.value0;
            }, function (p) {
                return function (q) {
                    var v = dominantMonom(dictEq)((dictCommutativeRing.Ring0()).Semiring0())(q);
                    var f = function ($copy_dividende) {
                        return function ($copy_acc) {
                            var $tco_var_dividende = $copy_dividende;
                            var $tco_done = false;
                            var $tco_result;
                            function $tco_loop(dividende, acc) {
                                var v1 = dominantMonom(dictEq)((dictCommutativeRing.Ring0()).Semiring0())(dividende);
                                var $145 = v1.value0 < v.value0;
                                if ($145) {
                                    $tco_done = true;
                                    return acc;
                                };
                                var r = Data_Semiring.mul((dictCommutativeRing.Ring0()).Semiring0())(v1.value1)(Data_DivisionRing.recip(dictDivisionRing)(v.value1));
                                var monom = Poly.create(Data_Map_Internal.insert(Data_Ord.ordInt)(v1.value0 - v.value0 | 0)(r)(Data_Map_Internal.empty));
                                var $146 = v1.value0 === 0;
                                if ($146) {
                                    $tco_done = true;
                                    return Data_Semiring.add(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))(acc)(monom);
                                };
                                $tco_var_dividende = Data_Ring.sub(ringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0())(dictCommutativeRing.Ring0()))(dividende)(Data_Semiring.mul(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))(monom)(q));
                                $copy_acc = Data_Semiring.add(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))(acc)(monom);
                                return;
                            };
                            while (!$tco_done) {
                                $tco_result = $tco_loop($tco_var_dividende, $copy_acc);
                            };
                            return $tco_result;
                        };
                    };
                    return f(p)(new Poly(Data_Map_Internal.empty));
                };
            }, function (p) {
                return function (q) {
                    var d = Data_EuclideanRing.div(euclideanRingPoly(dictEq)(dictDivisionRing)(dictCommutativeRing))(p)(q);
                    return Data_Ring.sub(ringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0())(dictCommutativeRing.Ring0()))(p)(Data_Semiring.mul(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))(d)(q));
                };
            });
        };
    };
};
var bezout = function (dictEq) {
    return function (dictCommutativeRing) {
        return function (dictDivisionRing) {
            return function (p1) {
                return function (p2) {
                    var f = function ($copy_v) {
                        var $tco_done = false;
                        var $tco_result;
                        function $tco_loop(v) {
                            var $152 = Data_Eq.eq(eqPoly(dictEq))(v.r)(Data_Semiring.zero(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0())));
                            if ($152) {
                                $tco_done = true;
                                return {
                                    u: v.u_,
                                    v: v.v_
                                };
                            };
                            var q = Data_EuclideanRing.div(euclideanRingPoly(dictEq)(dictDivisionRing)(dictCommutativeRing))(v.r_)(v.r);
                            var r = Data_Ring.sub(ringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0())(dictCommutativeRing.Ring0()))(v.r_)(Data_Semiring.mul(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))(q)(v.r));
                            var u = Data_Ring.sub(ringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0())(dictCommutativeRing.Ring0()))(v.u_)(Data_Semiring.mul(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))(q)(v.u));
                            var v1 = Data_Ring.sub(ringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0())(dictCommutativeRing.Ring0()))(v.v_)(Data_Semiring.mul(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))(q)(v.v));
                            $copy_v = {
                                r_: v.r,
                                r: r,
                                u_: v.u,
                                u: u,
                                v_: v.v,
                                v: v1
                            };
                            return;
                        };
                        while (!$tco_done) {
                            $tco_result = $tco_loop($copy_v);
                        };
                        return $tco_result;
                    };
                    var res = f({
                        r_: p1,
                        r: p2,
                        u_: Data_Semiring.one(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0())),
                        v_: Data_Semiring.zero(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0())),
                        u: Data_Semiring.zero(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0())),
                        v: Data_Semiring.one(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))
                    });
                    return res;
                };
            };
        };
    };
};
var gcd = function (dictEq) {
    return function (dictDivisionRing) {
        return function (dictCommutativeRing) {
            return function (p) {
                return function (q) {
                    var v = bezout(dictEq)(dictCommutativeRing)(dictDivisionRing)(p)(q);
                    return Data_Semiring.add(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))(Data_Semiring.mul(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))(v.u)(p))(Data_Semiring.mul(semiringPoly(dictEq)((dictCommutativeRing.Ring0()).Semiring0()))(v.v)(q));
                };
            };
        };
    };
};
var applyPoly = function (dictSemiring) {
    return function (v) {
        return function (x) {
            return Data_FoldableWithIndex.foldrWithIndex(Data_Map_Internal.foldableWithIndexMap)(function (i) {
                return function (v1) {
                    return function (acc) {
                        return Data_Semiring.add(dictSemiring)(acc)(Data_Semiring.mul(dictSemiring)(v1)(pow(dictSemiring)(x)(i)));
                    };
                };
            })(Data_Semiring.zero(dictSemiring))(v.value0);
        };
    };
};
var roots = function (pnum) {
    var p = liftC(pnum);
    var v = dominantMonom(Data_Complex.eqCartesian(Data_Eq.eqNumber))(Data_Complex.semiringCartesian(Data_Ring.ringNumber))(p);
    var z0 = new Data_Complex.Cartesian(1.2, 3.4);
    var unitary = Data_Functor.map(functorPoly)(function (v1) {
        return Data_EuclideanRing.div(Data_Complex.euclideanRingCartesianNumber)(v1)(v.value1);
    })(p);
    var th = function (k) {
        return function (xs) {
            return Data_Maybe.fromJust()(Data_Array.index(xs)(k));
        };
    };
    var indices = Data_Array.range(0)(v.value0 - 1 | 0);
    var f = function ($copy_goods) {
        return function ($copy_error$prime) {
            var $tco_var_goods = $copy_goods;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(goods, error$prime) {
                var $166 = error$prime < 1.0e-7;
                if ($166) {
                    $tco_done = true;
                    return goods;
                };
                var betters = Data_Functor.map(Data_Functor.functorArray)(function (i) {
                    var good = th(i)(goods);
                    var prod = Data_Foldable.foldr(Data_Foldable.foldableArray)(function (j) {
                        return function (acc) {
                            var $167 = i === j;
                            if ($167) {
                                return acc;
                            };
                            return Data_Semiring.mul(Data_Complex.semiringCartesian(Data_Ring.ringNumber))(acc)(Data_Ring.sub(Data_Complex.ringCartesian(Data_Ring.ringNumber))(good)(th(j)(goods)));
                        };
                    })(Data_Semiring.one(Data_Complex.semiringCartesian(Data_Ring.ringNumber)))(indices);
                    return Data_Ring.sub(Data_Complex.ringCartesian(Data_Ring.ringNumber))(good)(Data_EuclideanRing.div(Data_Complex.euclideanRingCartesianNumber)(applyPoly(Data_Complex.semiringCartesian(Data_Ring.ringNumber))(unitary)(good))(prod));
                })(indices);
                var error = (function () {
                    var v1 = Data_Ring.sub(ringPoly(Data_Complex.eqCartesian(Data_Eq.eqNumber))(Data_Complex.semiringCartesian(Data_Ring.ringNumber))(Data_Complex.ringCartesian(Data_Ring.ringNumber)))(unitary)(Data_Foldable.product(Data_Foldable.foldableArray)(semiringPoly(Data_Complex.eqCartesian(Data_Eq.eqNumber))(Data_Complex.semiringCartesian(Data_Ring.ringNumber)))(Data_Functor.map(Data_Functor.functorArray)(function (z) {
                        return Data_Ring.sub(ringPoly(Data_Complex.eqCartesian(Data_Eq.eqNumber))(Data_Complex.semiringCartesian(Data_Ring.ringNumber))(Data_Complex.ringCartesian(Data_Ring.ringNumber)))(monoPol(Data_Semiring.one(Data_Complex.semiringCartesian(Data_Ring.ringNumber)))(1))(monoPol(z)(0));
                    })(betters)));
                    return Data_Maybe.fromMaybe(0.0)(Data_Foldable.maximum(Data_Ord.ordNumber)(Data_Foldable.foldableArray)(Data_Functor.map(Data_Functor.functorArray)(Data_Functor.map(Data_Functor.functorFn)(Data_Functor.map(Data_Functor.functorFn)($$Math.sqrt)(Data_Complex.magnitudeSquared(Data_Ring.ringNumber)))(Data_Tuple.snd))(Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(v1.value0))));
                })();
                $tco_var_goods = betters;
                $copy_error$prime = error;
                return;
            };
            while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_goods, $copy_error$prime);
            };
            return $tco_result;
        };
    };
    var candidates = Data_Functor.map(Data_Functor.functorArray)(function (x) {
        return Data_Complex.pow(z0)(x);
    })(Data_Functor.map(Data_Functor.functorArray)(Data_Int.toNumber)(indices));
    return f(candidates)(1.0);
};
module.exports = {
    Poly: Poly,
    IntLiftable: IntLiftable,
    applyPoly: applyPoly,
    bezout: bezout,
    derivative: derivative,
    diff: diff,
    dominantMonom: dominantMonom,
    fromInt: fromInt,
    gcd: gcd,
    liftC: liftC,
    monoPol: monoPol,
    pow: pow,
    query: query,
    roots: roots,
    sortedMonoms: sortedMonoms,
    semigroupPoly: semigroupPoly,
    eqPoly: eqPoly,
    functorPoly: functorPoly,
    semiringPoly: semiringPoly,
    ringPoly: ringPoly,
    commutativeRingPoly: commutativeRingPoly,
    euclideanRingPoly: euclideanRingPoly,
    ordPoly: ordPoly,
    showPoly: showPoly,
    intIntLiftable: intIntLiftable,
    numberIntLiftable: numberIntLiftable,
    complexIntLiftable: complexIntLiftable,
    ratioIntLiftable: ratioIntLiftable
};
