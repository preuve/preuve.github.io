// Generated by purs version 0.13.3
"use strict";
var Data_CommutativeRing = require("../Data.CommutativeRing/index.js");
var Data_DivisionRing = require("../Data.DivisionRing/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ring = require("../Data.Ring/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var Data_Show = require("../Data.Show/index.js");
var $$Math = require("../Math/index.js");
var Cartesian = (function () {
    function Cartesian(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Cartesian.create = function (value0) {
        return function (value1) {
            return new Cartesian(value0, value1);
        };
    };
    return Cartesian;
})();
var showCartesian = function (dictShow) {
    return function (dictOrd) {
        return function (dictSemiring) {
            return function (dictRing) {
                return new Data_Show.Show(function (v) {
                    return Data_Show.show(dictShow)(v.value0) + ((function () {
                        var $28 = Data_Ord.lessThan(dictOrd)(v.value1)(Data_Semiring.zero(dictRing.Semiring0()));
                        if ($28) {
                            return "-" + Data_Show.show(dictShow)(Data_Ring.negate(dictRing)(v.value1));
                        };
                        return "+" + Data_Show.show(dictShow)(v.value1);
                    })() + "i");
                });
            };
        };
    };
};
var semiringCartesian = function (dictRing) {
    return new Data_Semiring.Semiring(function (v) {
        return function (v1) {
            return new Cartesian(Data_Semiring.add(dictRing.Semiring0())(v.value0)(v1.value0), Data_Semiring.add(dictRing.Semiring0())(v.value1)(v1.value1));
        };
    }, function (v) {
        return function (v1) {
            return new Cartesian(Data_Ring.sub(dictRing)(Data_Semiring.mul(dictRing.Semiring0())(v.value0)(v1.value0))(Data_Semiring.mul(dictRing.Semiring0())(v.value1)(v1.value1)), Data_Semiring.add(dictRing.Semiring0())(Data_Semiring.mul(dictRing.Semiring0())(v.value0)(v1.value1))(Data_Semiring.mul(dictRing.Semiring0())(v.value1)(v1.value0)));
        };
    }, new Cartesian(Data_Semiring.one(dictRing.Semiring0()), Data_Semiring.zero(dictRing.Semiring0())), new Cartesian(Data_Semiring.zero(dictRing.Semiring0()), Data_Semiring.zero(dictRing.Semiring0())));
};
var real = function (v) {
    return v.value0;
};
var imag = function (v) {
    return v.value1;
};
var i = function (dictSemiring) {
    return new Cartesian(Data_Semiring.zero(dictSemiring), Data_Semiring.one(dictSemiring));
};
var functorCartesian = new Data_Functor.Functor(function (f) {
    return function (v) {
        return new Cartesian(f(v.value0), f(v.value1));
    };
});
var ringCartesian = function (dictRing) {
    return new Data_Ring.Ring(function () {
        return semiringCartesian(dictRing);
    }, function (z1) {
        return function (z2) {
            return Data_Semiring.add(semiringCartesian(dictRing))(z1)(Data_Functor.map(functorCartesian)(function (v) {
                return Data_Semiring.mul(dictRing.Semiring0())(v)(Data_Ring.sub(dictRing)(Data_Semiring.zero(dictRing.Semiring0()))(Data_Semiring.one(dictRing.Semiring0())));
            })(z2));
        };
    });
};
var fromPolar = function (r) {
    return function (theta) {
        return new Cartesian(r * $$Math.cos(theta), r * $$Math.sin(theta));
    };
};
var eqCartesian = function (dictEq) {
    return new Data_Eq.Eq(function (v) {
        return function (v1) {
            return Data_Eq.eq(dictEq)(v.value0)(v1.value0) && Data_Eq.eq(dictEq)(v.value1)(v1.value1);
        };
    });
};
var conjugate = function (dictRing) {
    return function (v) {
        return new Cartesian(v.value0, Data_Ring.negate(dictRing)(v.value1));
    };
};
var magnitudeSquared = function (dictRing) {
    return function (z) {
        return real(Data_Semiring.mul(semiringCartesian(dictRing))(z)(conjugate(dictRing)(z)));
    };
};
var divisionRingCartesian = function (dictDivisionRing) {
    return new Data_DivisionRing.DivisionRing(function () {
        return ringCartesian(dictDivisionRing.Ring0());
    }, function (z) {
        return Data_Functor.map(functorCartesian)(function (v) {
            return Data_Semiring.mul((dictDivisionRing.Ring0()).Semiring0())(v)(Data_DivisionRing.recip(dictDivisionRing)(magnitudeSquared(dictDivisionRing.Ring0())(z)));
        })(conjugate(dictDivisionRing.Ring0())(z));
    });
};
var normalize = function (z) {
    return Data_Functor.map(functorCartesian)(function (v) {
        return v / $$Math.sqrt(magnitudeSquared(Data_Ring.ringNumber)(z));
    })(z);
};
var commutativeRingCartesian = function (dictCommutativeRing) {
    return new Data_CommutativeRing.CommutativeRing(function () {
        return ringCartesian(dictCommutativeRing.Ring0());
    });
};
var euclideanRingCartesianNumber = new Data_EuclideanRing.EuclideanRing(function () {
    return commutativeRingCartesian(Data_CommutativeRing.commutativeRingNumber);
}, (function () {
    var $65 = magnitudeSquared(Data_Ring.ringNumber);
    return function ($66) {
        return Data_Int.ceil($65($66));
    };
})(), function (z) {
    return function (z$prime) {
        return Data_Semiring.mul(semiringCartesian(Data_Ring.ringNumber))(z)(Data_DivisionRing.recip(divisionRingCartesian(Data_DivisionRing.divisionringNumber))(z$prime));
    };
}, function (z) {
    return function (z$prime) {
        return Data_Semiring.zero(semiringCartesian(Data_Ring.ringNumber));
    };
});
var euclideanRingCartesianInt = new Data_EuclideanRing.EuclideanRing(function () {
    return commutativeRingCartesian(Data_CommutativeRing.commutativeRingInt);
}, magnitudeSquared(Data_Ring.ringInt), function (z) {
    return function (z$prime) {
        return Data_Functor.map(functorCartesian)(Data_Int.round)(Data_EuclideanRing.div(euclideanRingCartesianNumber)(Data_Functor.map(functorCartesian)(Data_Int.toNumber)(z))(Data_Functor.map(functorCartesian)(Data_Int.toNumber)(z$prime)));
    };
}, function (z) {
    return function (z$prime) {
        return Data_Ring.sub(ringCartesian(Data_Ring.ringInt))(z)(Data_Semiring.mul(semiringCartesian(Data_Ring.ringInt))(z$prime)(Data_EuclideanRing.div(euclideanRingCartesianInt)(z)(z$prime)));
    };
});
var angle = function (v) {
    return $$Math.atan2(v.value1)(v.value0);
};
var pow = function (z) {
    return function (n) {
        return fromPolar($$Math.pow($$Math.sqrt(magnitudeSquared(Data_Ring.ringNumber)(z)))(n))(angle(z) * n);
    };
};
module.exports = {
    Cartesian: Cartesian,
    angle: angle,
    conjugate: conjugate,
    fromPolar: fromPolar,
    i: i,
    imag: imag,
    magnitudeSquared: magnitudeSquared,
    normalize: normalize,
    pow: pow,
    real: real,
    showCartesian: showCartesian,
    eqCartesian: eqCartesian,
    semiringCartesian: semiringCartesian,
    functorCartesian: functorCartesian,
    ringCartesian: ringCartesian,
    commutativeRingCartesian: commutativeRingCartesian,
    divisionRingCartesian: divisionRingCartesian,
    euclideanRingCartesianNumber: euclideanRingCartesianNumber,
    euclideanRingCartesianInt: euclideanRingCartesianInt
};
