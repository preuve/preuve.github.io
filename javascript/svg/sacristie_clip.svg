<svg id="svg" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" 
    style="background-color: #000;">
    <defs id="defs"/>

    <!-- you must wrap scripts in CDATA tags for SVG to be valid XML -->
    <script type="text/javascript"><![CDATA[
    const ns = "http://www.w3.org/2000/svg";
    const svg = document.getElementById('svg');
    const defs = document.getElementById('defs');

    //
    // FUNCTIONS
    //

    const cplx = (a, b) => { return { re: a, im: b };};
    const add = (z1, z2) => { return { re: z1.re + z2.re, im: z1.im + z2.im };};
    const conj = (z) => { return { re: z.re, im: -z.im };}
    const sqmod = (z) => z.re * z.re + z.im * z.im;
    const mul = (z1, z2) => { 
        return { 
            re: z1.re * z2.re - z1.im * z2.im, 
            im: z1.re * z2.im + z1.im * z2.re };
    };
    const sub = (z1, z2) => add(z1, mul(cplx(-1.0,0.0), z2));
    const inv = (z) => {
        var m2 = sqmod(z);
        return { re: z.re / m2, im: - z.im / m2 };
    };
    const div = (z1, z2) => mul(z1, inv(z2));
    const sqrt = (z2) => {
        var s = Math.sqrt(Math.sqrt(sqmod(z2))+z2.re);
        var s2 = Math.sqrt(2.0);
        var z = cplx(s/s2, z2.im / (s*s2));
        return [z, mul(cplx(-1.0,0.0),z)];
    };
    const exp = (z) => { 
        return { 
            re: Math.exp(z.re) * Math.cos(z.im),
            im: Math.exp(z.re) * Math.sin(z.im)};
    };
    const log = (z) => {
        var a = Math.atan2(z.im, z.re);
        return { re: Math.log(sqmod(z))/2, im: a };
    };
    const power = (z, n) => exp(mul(n,log(z)));
    const cos = (z) => 
        div(add(exp(mul(z,cplx(0,1))),exp(mul(z,cplx(0,-1)))),cplx(2,0));
    const sin = (z) => 
        div(sub(exp(mul(z,cplx(0,1))),exp(mul(z,cplx(0,-1)))),cplx(0,2));
    const tan = (z) => div(sin(z), cos(z));

    const color = Array.from({length:18}, (_,__)=>"#fff");

   /* const color = [
        "#f00", "#f00", 
        "#00f", "#00f", "#00f", "#00f", 
        "#0f0", "#0f0", "#0f0", "#0f0", 
        "#770", "#770", "#770", "#770",
        "#c0f", "#c0f", "#c0f", "#c0f" ];
*/
    const segment = (pt1,pt2,j,pattern) => {
        var line = document.createElementNS(ns, "line");
        line.setAttributeNS(null, "x1", pt1[0]);
        line.setAttributeNS(null, "y1", pt1[1]);
        line.setAttributeNS(null, "x2", pt2[0]);
        line.setAttributeNS(null, "y2", pt2[1]);
        line.setAttributeNS(null, "stroke", "#000");
        line.setAttributeNS(null, "stroke-width", 0.2);
        pattern.appendChild(line);
    };
    
   var cpt = 0;
    const polygon = (arr, j, pattern) => {
    
        var poly = document.createElementNS(ns, "polygon");
        var points = arr.reduce((acc, pt) => acc+`${pt[0]},${pt[1]} `, "");
        poly.setAttributeNS(null, "points", points);
        //poly.setAttributeNS(null, "stroke", color[j]);
        poly.setAttributeNS(null, "stroke-width", 0.1);
        var gr = document.createElementNS(ns, "linearGradient");
        gr.setAttributeNS(null, "id", `grad${cpt}`);
        gr.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
        let v = one(arr[0], arr[1]);
        
        if (((0<=j && j<=1) && v[1]<0) 
        || ((2<=j && j<=5) && v[0] <0)
        || ((6<=j && j<= 9) && v[0] <0) 
        || ((10<=j && j<=13) && v[1]<0)
        || ((14<=j && j<=17) && v[1]<0)) {
            gr.setAttributeNS(null, "x1", arr[0][0]);
            gr.setAttributeNS(null, "y1", arr[0][1]);
            gr.setAttributeNS(null, "x2", arr[0][0]+laceWidth*v[1]);
            gr.setAttributeNS(null, "y2", arr[0][1]-laceWidth*v[0]);
        } else {
            gr.setAttributeNS(null, "x1", arr[2][0]);
            gr.setAttributeNS(null, "y1", arr[2][1]);
            gr.setAttributeNS(null, "x2", arr[2][0]-laceWidth*v[1]);
            gr.setAttributeNS(null, "y2", arr[2][1]+laceWidth*v[0]);
        }

        var s0 = document.createElementNS(ns, "stop");
        s0.setAttributeNS(null, "offset", "0%");
        s0.setAttributeNS(null, "stop-color", "#fff");
        gr.appendChild(s0);
        var s2 = document.createElementNS(ns, "stop");
        s2.setAttributeNS(null, "offset", "45%");
        s2.setAttributeNS(null, "stop-color", "#777");
        gr.appendChild(s2);
        var s1 = document.createElementNS(ns, "stop");
        s1.setAttributeNS(null, "offset", "100%");
        s1.setAttributeNS(null, "stop-color", "#222");
        gr.appendChild(s1);
        defs.appendChild(gr);

        poly.setAttributeNS(null, "fill", `url(#grad${cpt})`);
        cpt++;

        pattern.appendChild(poly);
    };

    const coord = (id) => {
        var pt = document.getElementById(id);
        return [ Number(pt.getAttribute("cx")),
                    Number(pt.getAttribute("cy"))];
    };

    const line = (pt1, pt2) => {
        return [ pt2[1]-pt1[1], 
                    pt1[0]-pt2[0], 
                        pt2[0]*pt1[1]-pt1[0]*pt2[1] ];
     };

    const inter = (line1, line2) => {
        var denom = line1[0] * line2[1] - line1[1] * line2[0];
        return [ (line2[2] * line1[1] - line2[1] * line1[2]) / denom,
                 (line2[0] * line1[2] - line2[2] * line1[0]) / denom ];
    };

    const rotate = (pt, a) => 
        [ pt[0] * Math.cos(a) - pt[1] * Math.sin(a)
        , pt[0] * Math.sin(a) + pt[1] * Math.cos(a) ];

    const translate = (pt, v) => [pt[0] + v[0], pt[1] + v[1]];

    const dist = (pt1,pt2) => 
        Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
        
    const one = (po,pe) => {
        let v = [pe[0]-po[0], pe[1]-po[1]];
        let l = dist(v,[0,0]);
        return [v[0]/l, v[1]/l];
    };

    const sym = (ref, pt) => [ 2*ref[0]-pt[0], 2*ref[1]-pt[1] ];

    const d = pt => [ -pt[0], pt[1] ];
    const q = pt => [ pt[0], -pt[1] ];
    const b = pt => [ -pt[0], -pt[1] ];

    const up = pt => [pt[0], pt[1] - motifHeight];
    const down = pt => [pt[0], pt[1] + motifHeight];
    const left = pt => [pt[0] - motifWidth, pt[1]];
    const right = pt => [pt[0] + motifWidth, pt[1]];

    const t = 2*Math.PI/10;
    const phi = (1+Math.sqrt(5))/2;
    const cosPi10 = Math.sqrt((phi+2))/2;
    const k = 2*cosPi10/Math.sqrt(5);
    const h = k*phi;
    const l = k/phi;

    //
    // GRAPHICAL CONTENT
    //

    const tg = 0;
    const tD = 1;

    const angle = [108,36].map(a=>a*Math.PI/180);

    var radius = 24;
    var laceWidth = 6;
    var sizeX = 5;
    var sizeY = 3;

    var motifHeight = 2 * radius * k * (3*phi+2);
    var motifWidth =  2 * radius * (2*phi+1);

    svg.setAttributeNS(null, "height", 3*motifHeight);
    svg.setAttributeNS(null, "width", 5*motifWidth);
    svg.setAttributeNS(
        null, 
        "viewBox", 
        `-${3*motifWidth} -${motifHeight} ${5*motifWidth} ${3*motifHeight}`);
    
    var pattern = [];
    for(let m=0; m<sizeX; m++) {
        pattern.push([]);
        for(let n=0; n<sizeY; n++) {
            const clip = document.createElementNS(ns, "clipPath");
            clip.setAttributeNS(null, "id", `path${m}${n}`);
            const rect = document.createElementNS(ns, "rect");
            rect.setAttributeNS(null, "id", `clip${m}${n}`);
            rect.setAttributeNS(null, "height", motifHeight);
            rect.setAttributeNS(null, "width", motifWidth);
            rect.setAttributeNS(null, "x", (m-2)*motifWidth-motifWidth/2);
            rect.setAttributeNS(null, "y", -(n-2)*motifHeight-motifHeight/2);

            clip.appendChild(rect);
            defs.appendChild(clip);
            const g = document.createElementNS(ns, "g");
            g.setAttributeNS(null, "id", `pattern${m}${n}`);
            defs.appendChild(g);
            pattern[m].push(g);
            const use = document.createElementNS(ns, "use");
            use.setAttributeNS(null, "clip-path", `url(#path${m}${n})`);
            use.setAttributeNS(null, "href", `#pattern${m}${n}`);
            svg.appendChild(use);
        }
    }

    var p0 = [radius*Math.cos(0),-radius*Math.sin(0)];
    var p1 = [radius*Math.cos(t),-radius*Math.sin(t)];
    var p2 = [radius*Math.cos(2*t),-radius*Math.sin(2*t)];

    var v0 = one(p0,p2);
    var v1 = one(p1,d(p2));
    var v2 = one(p2,d(p1));
    var v3 = one(d(p2),b(p0));
    var v4 = one(d(p1),b(p1));

    var b0 = [(phi+1)*radius, 0];
    var p3 = [b0[0]-k*radius*v2[0], b0[1]-k*radius*v2[1]];
    var b1 = rotate(b0,-t);
    var c0 = inter(line(p0,b1),line(p1,q(p3)));
    var q4 = rotate(p3,t);
    var p4 = q(q4);
    var e0 = [q4[0]-k*radius*v3[0], q4[1]-k*radius*v3[1]];
    var e1 = rotate(e0,-t);
    var p10 = sym(e1,p3);
    var p12 = sym(e1,q(p3));
    var p19 = rotate(p3,-t);
    var p11 = sym(e1,b0);
    var p8 = rotate(p4,-t);
    var e2 = rotate(e1,-t);
    var p18 = sym(e2,p8);

    var p20 = rotate(p10,-t);
    var p7 = rotate(p19,-t);
    var p6 = rotate(p18,-t);
    var p16 = rotate(p12,-t);
    var f0 = sym(e2,b1);
    var p13 = sym(f0, p7);
    var g0 = sym(f0,p6);
    var p17 = rotate(g0,-t);
    var p5 = inter(line(e0,q4),line(e1,p4));
    var p15 = sym(e2,p2);
    var c2 = rotate(c0,-2*t);
    var p9 = sym(e2,c2);
    var f1 = inter(line(p18,p9),line(g0,p12));
    var f2 = rotate(f1,-t);
    var p22 = sym(f2,p6);
    var e3 = rotate(e2,-t);
    var p14 = sym(f2,e3);
    var p21 = [p14[0]+phi*radius, p14[1]];

    var g1 = [f2[0]-k*phi**2*radius*v2[0], f2[1]-k*phi**2*radius*v2[1]];
    var b2 = rotate(b1,-t);
    var c1 = rotate(c0,-t);

    var w0 = [-k*radius*v0[0],-k*radius*v0[1]];
    var w1 = [-k*phi**2*radius*v1[0], -k*phi**2*radius*v1[1]];

    var correction = (p, q, out) => {
        var l1,l2,l3,l4,l5,l6,l7;
        var supsup, supinf, infsup, infinf;

        l1 = line(p,q);
        l2 = [l1[0],l1[1],l1[2]+laceWidth*Math.sqrt(l1[0]**2+l1[1]**2)];
        l3 = [l1[0],l1[1],l1[2]-laceWidth*Math.sqrt(l1[0]**2+l1[1]**2)];

        l4 = line(p,out);
        l5 = [l4[0],l4[1],l4[2]+laceWidth*Math.sqrt(l4[0]**2+l4[1]**2)];
        l6 = [l4[0],l4[1],l4[2]-laceWidth*Math.sqrt(l4[0]**2+l4[1]**2)];

        supsup = inter(l2,l5);
        supinf = inter(l2,l6);
        infsup = inter(l3,l5);
        infinf = inter(l3,l6);

        l7 = line(supsup,infinf);
        if((l7[0]*q[0]+l7[1]*q[1]+l7[2])*(l7[0]*out[0]+l7[1]*out[1]+l7[2]) < 0)
            return [ supsup, infinf];
        return [ supinf, infsup ];
    };

    const mapper = (pt,m,n) => {
        let [x,y] = pt;
        [x,y] = [x+(m-2)*motifWidth, y-(n-2)*motifHeight];
        let z = cplx(x,y);
        //z = add(z,cplx(0*motifWidth,-motifHeight/2));
        //z = div(z,cplx(radius**5,0));
        //z = add(cplx(1,0),mul(z,z));
        //z = mul(tan(z),cplx(radius**5,0));
        return [z.re,z.im];
    };
    
    var thread = (m,n,j) => {

        var xs = motif[j].map(x=> {
            if (x.length !== 0) {
                if(x[1].hasOwnProperty('length'))
                    return [x[0], mapper(x[1],m,n)];
                else return mapper(x,m,n);
            } else return x;
        });

        var i = 0;
        while (i < xs.length-2) {
            var beg = xs[i];
            var p = xs[i+1];
            var end = xs[i+2];

            var a1, a2, a3, a4;
            var out = undefined;
            var r, v, z;

            if(beg.length==2) {
                v = one(beg[1],p);
                vp = [-v[1], v[0]];
                r = rotate(v,angle[beg[0]]);
                a1 = [p[0]-laceWidth*vp[0], p[1]-laceWidth*vp[1]];
                a2 = [p[0]+laceWidth*vp[0], p[1]+laceWidth*vp[1]];
                if(end.length==2) out = end[1]; else if (xs[i+3]) out = xs[i+3];
                if(out) [a1, a2] = correction(p,beg[1],out);
                out = undefined;
                z = laceWidth/Math.sin((angle[beg[0]]));
                a3 = [beg[1][0]+z*(r[0]+v[0]),beg[1][1]+z*(r[1]+v[1])];
                a4 = [beg[1][0]+z*(-r[0]+v[0]),beg[1][1]+z*(-r[1]+v[1])];

                polygon([a1,a4,a3,a2],j,pattern[m][n]);
                segment(a1,a4,j,pattern[m][n]);
                segment(a3,a4,j,pattern[m][n]);
                segment(a3,a2,j,pattern[m][n]);
            } 

            if(end.length==2) {
                v = one(p,end[1]);
                vp = [v[1], -v[0]];
                z = laceWidth/Math.sin((angle[end[0]]));
                r = rotate(v,angle[end[0]]);
                a1 = [p[0]-laceWidth*vp[0], p[1]-laceWidth*vp[1]];
                a2 = [p[0]+laceWidth*vp[0], p[1]+laceWidth*vp[1]];
                a3 = [end[1][0]+z*(r[0]-v[0]),end[1][1]+z*(r[1]-v[1])];
                a4 = [end[1][0]+z*(-r[0]-v[0]),end[1][1]+z*(-r[1]-v[1])];
                if(beg.length==2) out = beg[1]; else if (xs[i-1]) out = xs[i-1];
                if(out) [a1, a2] = correction(p, end[1], out);
                out = undefined;

                polygon([a1,a3,a4,a2],j,pattern[m][n]);
                segment(a1,a3,j,pattern[m][n]);
                segment(a3,a4,j,pattern[m][n]);
                segment(a4,a2,j,pattern[m][n]);

            } else {
                if(xs[i+3]) {
                    v = one(p,xs[i+3]);
                    vp = [v[1], -v[0]];
                    a1 = [p[0]-laceWidth*vp[0], p[1]-laceWidth*vp[1]];
                    a2 = [p[0]+laceWidth*vp[0], p[1]+laceWidth*vp[1]];
                    if(beg[1]) [a1, a2] = correction(p, xs[i+3], beg[1]);
                    a3 = [xs[i+3][0]-laceWidth*vp[0], xs[i+3][1]-laceWidth*vp[1]];
                    a4 = [xs[i+3][0]+laceWidth*vp[0], xs[i+3][1]+laceWidth*vp[1]];
                    if(xs[i+4][1]) out = xs[i+4][1]; 
                    if(out) [a4, a3] = correction(xs[i+3], p, out);
                    out = undefined;

                    polygon([a1,a3, a4,a2],j,pattern[m][n]);
                    segment(a1,a3,j,pattern[m][n]);
                    segment(a2,a4,j,pattern[m][n]);
                }
            }
        i=i+2;
        }
    };

    var threads = () => Array.from({length: motif.length}, 
        (_,i)=>i).forEach(xs => {
            for(let m=0; m<sizeX; m++)
                for(let n=0; n<sizeY; n++)
                    thread(m,n,xs);
        });

    var motif = [
        [[], up(b(f0)) , [], d(p21), [tg, d(g1)], d(p20), [tD, d(e2)], d(p19), [tg, d(c0)],
         d(p0), [tD, b(b1)], b(p19), [], b(p20), [tD, b(f0)], b(p21), [], down(d(g1)), []],

        [[], down(f0), [], q(p21), [tg, q(g1)], q(p20), [tD, q(e2)], q(p19), 
         [tg, q(c0)], p0, [tD, b1], p19, [], p20, [tD, f0], p21, [] , up(q(g1)), []],

        [[tg, d(p9)], d(p15), [tD, d(f0)], d(p16), [tg, d(p17)]],

        [[tg, d(p5)], d(p4), [tD, d(b1)], d(p2), [tg, c2], 
        p8, [tD, e2], p18, [tg, p9]],

        [[tg, b(p9)], b(p18), [tD, b(e2)], b(p8), [tg, b(c2)], q(p2), 
        [tD, q(b1)], q(p4), [tg, p5]],

        [[tg, q(p17)], q(p16), [tD, q(f0)], q(p15), [tg, q(p9)]],

        [[], translate(d(p9),b(w0)), [tD, d(f1)], d(p18), [], d(p8), [tD, d(b2)], 
        p2, [tg, c1], p4, [tD, e1], translate(p5,w0), []],

        [[], translate(b(p5),b(w0)), [tD, b(e1)], b(p4), [tg, b(c1)], b(p2), [tD, q(b2)], 
        q(p8), [], q(p18), [tD, q(f1)], translate(q(p9),w0), []],

        [[], translate(b(p9),b(w0)), [], b(p15), [tg, b(g0)], b(p16), 
        [tD, b(f2)], translate(b(p17),w0), []],

        [[], translate(p9,w0), [], p15, [tg, g0], p16, [tD, f2], translate(p17,b(w0)), []],

        [[tD, d(p11)], d(p12), [tg, d(g0)], d(p13), [tD, d(p14)]],

        [[tD, b(p11)], b(p10), [], b(p3), [tD, b(b0)], d(p1), [tg, d(c1)], 
        d(p7), [tD, e3], p6, [], p22, [tD, p14]],

        //[[tD, q(p14)], q(p13), [tg, q(g0)], q(p12), [tD, q(p11)]],
        [[tD, q(p11)], q(p12), [tg, q(g0)], q(p13), [tD, q(p14)] ],

        [[tD, b(p14)], b(p22), [], b(p6), [tD, b(e3)], q(p7), [tg, q(c1)], 
        q(p1), [tD, b0], p3, [], p10, [tD, p11]],

        [[], left(q(p10)), [], b(p12), [tD, b(f1)], b(p13), [tg, b(g1)], translate(b(p14),w1), []],

        [[], left(p12), [], d(p10), [tD, d(e1)], d(p3), [tg, b(c0)], b(p1),
        [tD, b(b2)], b(p7), [], q(p6), [tD, q(f2)], q(p22), [], translate(q(p14),w1), []],

        [[], translate(q(p11),w1), [], q(p10), [tD, q(e1)], q(p3), [tg, c0], p1, [tD, b2], 
        p7, [], d(p6), [tD, d(f2)], d(p22), [], translate(d(p14),b(w1)), []],

        [[], right(d(p10)), [], p12, [tD, f1], p13, [tg, g1], translate(p14,b(w1)), []]
     ];

    threads();
    ]]></script>
 </svg> 
