<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" 
    style="background-color: #000;">
<defs id="defs">
 <pattern id="Pattern" patternUnits="userSpaceOnUse" />
 </defs>
 <rect fill="url(#Pattern)" stroke="black" width="100%" height="100%"/>
    <!-- you must wrap scripts in CDATA tags for SVG to be valid XML -->
    <script type="text/javascript"><![CDATA[
    const ns = "http://www.w3.org/2000/svg";
    const pattern = document.getElementById('Pattern');
    //
    // FUNCTIONS
    //
    
    const dot = (point,name,color,size) => {
        var circle = document.createElementNS(ns, "circle");
        var x = point[0];
        var y = point[1];
        circle.setAttributeNS(null, "id", name);
        circle.setAttributeNS(null, "cx", x);
        circle.setAttributeNS(null, "cy", y);
        circle.setAttributeNS(null, "r", size+1);
        circle.setAttributeNS(null, "fill", color);
        circle.setAttributeNS(null, "stroke", "none");
        pattern.appendChild(circle);
    };

    const color = Array.from({length:18}, (_,__)=>"#fff");
/*
    const color = [
        "#f00", "#f00", 
        "#00f", "#00f", "#00f", "#00f", 
        "#0f0", "#0f0", "#0f0", "#0f0", 
        "#770", "#770", "#770", "#770",
        "#c0f", "#c0f", "#c0f", "#c0f" ];
*/
    const segment = (pt1,pt2,j) => {
        var line = document.createElementNS(ns, "line");
        line.setAttributeNS(null, "x1", pt1[0]);
        line.setAttributeNS(null, "y1", pt1[1]);
        line.setAttributeNS(null, "x2", pt2[0]);
        line.setAttributeNS(null, "y2", pt2[1]);
        line.setAttributeNS(null, "stroke", "#000");
        line.setAttributeNS(null, "stroke-width", 0.2);
        pattern.appendChild(line);
    };

    var cpt = 0;
    const defs = document.getElementById('defs');
    
    const polygon = (arr, j) => {
        /*
        var poly = document.createElementNS(ns, "polygon");
        var points = arr.reduce((acc, pt) => acc+`${pt[0]},${pt[1]} `, "");
        poly.setAttributeNS(null, "points", points);
        poly.setAttributeNS(null, "stroke", color[j]);
        poly.setAttributeNS(null, "stroke-width", 0.1);
        poly.setAttributeNS(null, "fill", color[j]);
        pattern.appendChild(poly);
        */
        
        
              var poly = document.createElementNS(ns, "polygon");
              var points = arr.reduce((acc, pt) => acc+`${pt[0]},${pt[1]} `, "");
              poly.setAttributeNS(null, "points", points);
              poly.setAttributeNS(null, "stroke", color[j]);
              poly.setAttributeNS(null, "stroke-width", 0.1);
             
              var re = arr[1][0] - arr[0][0];
              var im = arr[1][1] - arr[0][1];
              
               poly.setAttributeNS(null, 
                   "transform", 
                   `rotate(${(-Math.atan2(im,re))/Math.PI*180})`);
               
      
              var gr = document.createElementNS(ns, "linearGradient");
              gr.setAttributeNS(null, "id", `grad${cpt}`);
              
              var s0 = document.createElementNS(ns, "stop");
              s0.setAttributeNS(null, "offset", "0%");
              s0.setAttributeNS(null, "stop-color", "#000");
              gr.appendChild(s0);
              var s1 = document.createElementNS(ns, "stop");
              s1.setAttributeNS(null, "offset", "100%");
              s1.setAttributeNS(null, "stop-color", "#fff");
              gr.appendChild(s1);
              defs.appendChild(gr);
              
              poly.setAttributeNS(null, "fill", `url(#grad${cpt})`);
              cpt++;
             
               var g = document.createElementNS(ns, "g");
             g.setAttributeNS(null, 
                   "transform", 
                   `rotate(${(-Math.atan2(im,re))/Math.PI*180})`);
                   
              g.appendChild(poly);
              pattern.appendChild(g);
      
    };

    const coord = (id) => {
        var pt = document.getElementById(id);
        return [ Number(pt.getAttribute("cx")),
                    Number(pt.getAttribute("cy"))];
    };

    const line = (pt1, pt2) => {
        return [ pt2[1]-pt1[1], 
                    pt1[0]-pt2[0], 
                        pt2[0]*pt1[1]-pt1[0]*pt2[1] ];
     };

    const inter = (line1, line2) => {
        var denom = line1[0] * line2[1] - line1[1] * line2[0];
        return [ (line2[2] * line1[1] - line2[1] * line1[2]) / denom,
                 (line2[0] * line1[2] - line2[2] * line1[0]) / denom ];
    };

    const rotate = (pt, a) => 
        [ pt[0] * Math.cos(a) - pt[1] * Math.sin(a)
        , pt[0] * Math.sin(a) + pt[1] * Math.cos(a) ];

    const translate = (pt, v) => [pt[0] + v[0], pt[1] + v[1]];

    const dist = (pt1,pt2) => 
        Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
        
    const one = (po,pe) => {
        let v = [pe[0]-po[0], pe[1]-po[1]];
        let l = dist(v,[0,0]);
        return [v[0]/l, v[1]/l];
    };

    const sym = (ref, pt) => [ 2*ref[0]-pt[0], 2*ref[1]-pt[1] ];

    const d = pt => [ -pt[0], pt[1] ];
    const q = pt => [ pt[0], -pt[1] ];
    const b = pt => [ -pt[0], -pt[1] ];

    const up = pt => [pt[0], pt[1] - motifHeight];
    const down = pt => [pt[0], pt[1] + motifHeight];
    const left = pt => [pt[0] - motifWidth, pt[1]];
    const right = pt => [pt[0] + motifWidth, pt[1]];

    const t = 2*Math.PI/10;
    const phi = (1+Math.sqrt(5))/2;
    const cosPi10 = Math.sqrt((phi+2))/2;
    const k = 2*cosPi10/Math.sqrt(5);
    const h = k*phi;
    const l = k/phi;

    //
    // GRAPHICAL CONTENT
    //

    const tg = 0;
    const tD = 1;

    const angle = [108,36].map(a=>a*Math.PI/180);

    var radius = 10;
    var laceWidth = 2.15;

    var motifHeight = 2 * radius * k * (3*phi+2);
    var motifWidth =  2 * radius * (2*phi+1);

    pattern.setAttributeNS(null, "height", motifHeight);
    pattern.setAttributeNS(null, "width", motifWidth);
    pattern.setAttributeNS(
        null, 
        "viewBox", 
        `-${motifWidth/2} -${motifHeight/2} ${motifWidth} ${motifHeight}`);

    var p0 = [radius*Math.cos(0),-radius*Math.sin(0)];
    var p1 = [radius*Math.cos(t),-radius*Math.sin(t)];
    var p2 = [radius*Math.cos(2*t),-radius*Math.sin(2*t)];

    var v0 = one(p0,p2);
    var v1 = one(p1,d(p2));
    var v2 = one(p2,d(p1));
    var v3 = one(d(p2),b(p0));
    var v4 = one(d(p1),b(p1));

    var b0 = [(phi+1)*radius, 0];
    var p3 = [b0[0]-k*radius*v2[0], b0[1]-k*radius*v2[1]];
    var b1 = rotate(b0,-t);
    var c0 = inter(line(p0,b1),line(p1,q(p3)));
    var q4 = rotate(p3,t);
    var p4 = q(q4);
    var e0 = [q4[0]-k*radius*v3[0], q4[1]-k*radius*v3[1]];
    var e1 = rotate(e0,-t);
    var p10 = sym(e1,p3);
    var p12 = sym(e1,q(p3));
    var p19 = rotate(p3,-t);
    var p11 = sym(e1,b0);
    var p8 = rotate(p4,-t);
    var e2 = rotate(e1,-t);
    var p18 = sym(e2,p8);

    var p20 = rotate(p10,-t);
    var p7 = rotate(p19,-t);
    var p6 = rotate(p18,-t);
    var p16 = rotate(p12,-t);
    var f0 = sym(e2,b1);
    var p13 = sym(f0, p7);
    var g0 = sym(f0,p6);
    var p17 = rotate(g0,-t);
    var p5 = inter(line(e0,q4),line(e1,p4));
    var p15 = sym(e2,p2);
    var c2 = rotate(c0,-2*t);
    var p9 = sym(e2,c2);
    var f1 = inter(line(p18,p9),line(g0,p12));
    var f2 = rotate(f1,-t);
    var p22 = sym(f2,p6);
    var e3 = rotate(e2,-t);
    var p14 = sym(f2,e3);
    var p21 = [p14[0]+phi*radius, p14[1]];

    var g1 = [f2[0]-k*phi**2*radius*v2[0], f2[1]-k*phi**2*radius*v2[1]];
    var b2 = rotate(b1,-t);
    var c1 = rotate(c0,-t);

    var w0 = [-k*radius*v0[0],-k*radius*v0[1]];
    var w1 = [-k*phi**2*radius*v1[0], -k*phi**2*radius*v1[1]];

    var correction = (p, q, out) => {
        var l1,l2,l3,l4,l5,l6,l7;
        var supsup, supinf, infsup, infinf;

        l1 = line(p,q);
        l2 = [l1[0],l1[1],l1[2]+laceWidth*Math.sqrt(l1[0]**2+l1[1]**2)];
        l3 = [l1[0],l1[1],l1[2]-laceWidth*Math.sqrt(l1[0]**2+l1[1]**2)];

        l4 = line(p,out);
        l5 = [l4[0],l4[1],l4[2]+laceWidth*Math.sqrt(l4[0]**2+l4[1]**2)];
        l6 = [l4[0],l4[1],l4[2]-laceWidth*Math.sqrt(l4[0]**2+l4[1]**2)];

        supsup = inter(l2,l5);
        supinf = inter(l2,l6);
        infsup = inter(l3,l5);
        infinf = inter(l3,l6);

        l7 = line(supsup,infinf);
        if((l7[0]*q[0]+l7[1]*q[1]+l7[2])*(l7[0]*out[0]+l7[1]*out[1]+l7[2]) < 0)
            return [ supsup, infinf];
        return [ supinf, infsup ];
    };

    var thread = j => {

        var xs = motif[j];
        var i = 0;
        while (i < xs.length-2) {
            var beg = xs[i];
            var p = xs[i+1];
            var end = xs[i+2];

            var a1, a2, a3, a4;
            var out = undefined;
            var r, v, z;

            if(beg.length==2) {
                v = one(beg[1],p);
                vp = [-v[1], v[0]];
                r = rotate(v,angle[beg[0]]);
                a1 = [p[0]-laceWidth*vp[0], p[1]-laceWidth*vp[1]];
                a2 = [p[0]+laceWidth*vp[0], p[1]+laceWidth*vp[1]];
                if(end.length==2) out = end[1]; else if (xs[i+3]) out = xs[i+3];
                if(out) [a1, a2] = correction(p,beg[1],out);
                out = undefined;
                z = laceWidth/Math.sin((angle[beg[0]]));
                a3 = [beg[1][0]+z*(r[0]+v[0]),beg[1][1]+z*(r[1]+v[1])];
                a4 = [beg[1][0]+z*(-r[0]+v[0]),beg[1][1]+z*(-r[1]+v[1])];

                polygon([a1,a4,a3,a2],j);
                segment(a1,a4,j);
                segment(a3,a4,j);
                segment(a3,a2,j);
            } 

            if(end.length==2) {
                v = one(p,end[1]);
                vp = [v[1], -v[0]];
                z = laceWidth/Math.sin((angle[end[0]]));
                r = rotate(v,angle[end[0]]);
                a1 = [p[0]-laceWidth*vp[0], p[1]-laceWidth*vp[1]];
                a2 = [p[0]+laceWidth*vp[0], p[1]+laceWidth*vp[1]];
                a3 = [end[1][0]+z*(r[0]-v[0]),end[1][1]+z*(r[1]-v[1])];
                a4 = [end[1][0]+z*(-r[0]-v[0]),end[1][1]+z*(-r[1]-v[1])];
                if(beg.length==2) out = beg[1]; else if (xs[i-1]) out = xs[i-1];
                if(out) [a1, a2] = correction(p, end[1], out);
                out = undefined;

                polygon([a1,a3,a4,a2],j);
                segment(a1,a3,j);
                segment(a3,a4,j);
                segment(a4,a2,j);

            } else {
                if(xs[i+3]) {
                    v = one(p,xs[i+3]);
                    vp = [v[1], -v[0]];
                    a1 = [p[0]-laceWidth*vp[0], p[1]-laceWidth*vp[1]];
                    a2 = [p[0]+laceWidth*vp[0], p[1]+laceWidth*vp[1]];
                    if(beg[1]) [a1, a2] = correction(p, xs[i+3], beg[1]);
                    a3 = [xs[i+3][0]-laceWidth*vp[0], xs[i+3][1]-laceWidth*vp[1]];
                    a4 = [xs[i+3][0]+laceWidth*vp[0], xs[i+3][1]+laceWidth*vp[1]];
                    if(xs[i+4][1]) out = xs[i+4][1]; 
                    if(out) [a4, a3] = correction(xs[i+3], p, out);
                    out = undefined;

                    polygon([a1,a3, a4,a2],j);
                    segment(a1,a3,j);
                    segment(a2,a4,j);
                }
            }
        i=i+2;
        }
    };

    var threads = () => Array.from({length: motif.length}, 
        (_,i)=>i).forEach(xs => thread(xs));

    var motif = [
        [[], up(b(f0)) , [], d(p21), [tg, d(g1)], d(p20), [tD, d(e2)], d(p19), [tg, d(c0)],
         d(p0), [tD, b(b1)], b(p19), [], b(p20), [tD, b(f0)], b(p21), [], down(d(g1)), []],

        [[], down(f0), [], q(p21), [tg, q(g1)], q(p20), [tD, q(e2)], q(p19), 
         [tg, q(c0)], p0, [tD, b1], p19, [], p20, [tD, f0], p21, [] , up(q(g1)), []],

        [[tg, d(p9)], d(p15), [tD, d(f0)], d(p16), [tg, d(p17)]],

        [[tg, d(p5)], d(p4), [tD, d(b1)], d(p2), [tg, c2], 
        p8, [tD, e2], p18, [tg, p9]],

        [[tg, b(p9)], b(p18), [tD, b(e2)], b(p8), [tg, b(c2)], q(p2), 
        [tD, q(b1)], q(p4), [tg, p5]],

        [[tg, q(p17)], q(p16), [tD, q(f0)], q(p15), [tg, q(p9)]],

        [[], translate(d(p9),b(w0)), [tD, d(f1)], d(p18), [], d(p8), [tD, d(b2)], 
        p2, [tg, c1], p4, [tD, e1], translate(p5,w0), []],

        [[], translate(b(p5),b(w0)), [tD, b(e1)], b(p4), [tg, b(c1)], b(p2), [tD, q(b2)], 
        q(p8), [], q(p18), [tD, q(f1)], translate(q(p9),w0), []],

        [[], translate(b(p9),b(w0)), [], b(p15), [tg, b(g0)], b(p16), 
        [tD, b(f2)], translate(b(p17),w0), []],

        [[], translate(p9,w0), [], p15, [tg, g0], p16, [tD, f2], translate(p17,b(w0)), []],

        [[tD, d(p11)], d(p12), [tg, d(g0)], d(p13), [tD, d(p14)]],

        [[tD, b(p11)], b(p10), [], b(p3), [tD, b(b0)], d(p1), [tg, d(c1)], 
        d(p7), [tD, e3], p6, [], p22, [tD, p14]],

        [[tD, q(p14)], q(p13), [tg, q(g0)], q(p12), [tD, q(p11)]],

        [[tD, b(p14)], b(p22), [], b(p6), [tD, b(e3)], q(p7), [tg, q(c1)], 
        q(p1), [tD, b0], p3, [], p10, [tD, p11]],

        [[], left(q(p10)), [], b(p12), [tD, b(f1)], b(p13), [tg, b(g1)], translate(b(p14),w1), []],

        [[], left(p12), [], d(p10), [tD, d(e1)], d(p3), [tg, b(c0)], b(p1),
        [tD, b(b2)], b(p7), [], q(p6), [tD, q(f2)], q(p22), [], translate(q(p14),w1), []],

        [[], translate(q(p11),w1), [], q(p10), [tD, q(e1)], q(p3), [tg, c0], p1, [tD, b2], 
        p7, [], d(p6), [tD, d(f2)], d(p22), [], translate(d(p14),b(w1)), []],

        [[], right(d(p10)), [], p12, [tD, f1], p13, [tg, g1], translate(p14,b(w1)), []]
     ];

    threads();
    ]]></script>
 </svg> 
