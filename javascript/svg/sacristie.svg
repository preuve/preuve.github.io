<svg id="svg" xmlns="http://www.w3.org/2000/svg" width="1000" height="1000" 
    style="background-color: #fff;">
    <defs id="defs"/>

    <!-- you must wrap scripts in CDATA tags for SVG to be valid XML -->
    <script type="text/javascript"><![CDATA[
    const ns = "http://www.w3.org/2000/svg";
    const svg = document.getElementById('svg');
    const defs = document.getElementById('defs');

    //
    // FUNCTIONS
    //

    const cplx = (a, b) => { return { re: a, im: b };};
    const add = (z1, z2) => { return { re: z1.re + z2.re, im: z1.im + z2.im };};
    const conj = (z) => { return { re: z.re, im: -z.im };}
    const sqmod = (z) => z.re * z.re + z.im * z.im;
    const mul = (z1, z2) => { 
        return { 
            re: z1.re * z2.re - z1.im * z2.im, 
            im: z1.re * z2.im + z1.im * z2.re };
    };
    const sub = (z1, z2) => add(z1, mul(cplx(-1,0), z2));
    const inv = (z) => {
        var m2 = sqmod(z);
        return { re: z.re / m2, im: - z.im / m2 };
    };
    const div = (z1, z2) => mul(z1, inv(z2));
    const sqrt = (z2) => {
        var s = Math.sqrt(Math.sqrt(sqmod(z2))+z2.re);
        var s2 = Math.sqrt(2);
        var z = cplx(s/s2, z2.im / (s*s2));
        return [z, mul(cplx(-1,0),z)];
    };
    const exp = (z) => { 
        return { 
            re: Math.exp(z.re) * Math.cos(z.im),
            im: Math.exp(z.re) * Math.sin(z.im)};
    };
    const log = (z) => {
        var a = Math.atan2(z.im, z.re);
        return { re: Math.log(sqmod(z))/2, im: a };
    };
    const power = (z, n) => exp(mul(n,log(z)));
    const cos = (z) => 
        div(add(exp(mul(z,cplx(0,1))),exp(mul(z,cplx(0,-1)))),cplx(2,0));
    const sin = (z) => 
        div(sub(exp(mul(z,cplx(0,1))),exp(mul(z,cplx(0,-1)))),cplx(0,2));
    const tan = (z) => div(sin(z), cos(z));

    const atan = (z) =>  mul(cplx(0,-0.5),log(div(sub(cplx(0,1),z),add(cplx(0,1),z))));

    const color = Array.from({length:10}, (_,__)=>"#777");
/*
    const color = [
        "#f00", "#f00", 
        "#00f", "#00f", 
        "#0f0", "#0f0", 
        "#770", "#770",
        "#c0f", "#c0f",];
*/
    const segment = (pt1,pt2,j) => {
        var line = document.createElementNS(ns, "line");
        line.setAttributeNS(null, "x1", pt1[0]);
        line.setAttributeNS(null, "y1", pt1[1]);
        line.setAttributeNS(null, "x2", pt2[0]);
        line.setAttributeNS(null, "y2", pt2[1]);
        line.setAttributeNS(null, "stroke", "#000");
        line.setAttributeNS(null, "stroke-width", 0.2);
      //  svg.appendChild(line);
    };
    
    var cpt = 0;
    const polygon = (arr, j) => {
    
        var poly = document.createElementNS(ns, "polygon");
        var points = arr.reduce((acc, pt) => acc+`${pt[0]},${pt[1]} `, "");
        poly.setAttributeNS(null, "points", points);
        //poly.setAttributeNS(null, "stroke", color[j]);
        poly.setAttributeNS(null, "stroke-width", 0.1);
        var gr = document.createElementNS(ns, "linearGradient");
        gr.setAttributeNS(null, "id", `grad${cpt}`);
        gr.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
        let v = one(arr[0], arr[1]);
        
        if (((0<=j && j<=1) && v[1]<0) 
        || ((2<=j && j<=3) && v[0]<0)
        || ((4<=j && j<=5) && v[0]<0) 
        || ((6<=j && j<=7) && v[1]<0)
        || ((8<=j && j<=9) && v[1]<0)) {
            gr.setAttributeNS(null, "x1", arr[0][0]);
            gr.setAttributeNS(null, "y1", arr[0][1]);
            gr.setAttributeNS(null, "x2", arr[0][0]+laceWidth(middle(arr[0], arr[1]))*v[1]);
            gr.setAttributeNS(null, "y2", arr[0][1]-laceWidth(middle(arr[0], arr[1]))*v[0]);
        } else {
            gr.setAttributeNS(null, "x1", arr[2][0]);
            gr.setAttributeNS(null, "y1", arr[2][1]);
            
            gr.setAttributeNS(null, "x2", arr[2][0]-laceWidth(middle(arr[0], arr[1]))*v[1]);
            gr.setAttributeNS(null, "y2", arr[2][1]+laceWidth(middle(arr[0], arr[1]))*v[0]);
            
        }

        var s0 = document.createElementNS(ns, "stop");
        s0.setAttributeNS(null, "offset", "0%");
        s0.setAttributeNS(null, "stop-color", "#444");
        gr.appendChild(s0);
        var s2 = document.createElementNS(ns, "stop");
        s2.setAttributeNS(null, "offset", "45%");
        s2.setAttributeNS(null, "stop-color", color[j]);
        gr.appendChild(s2);
        var s1 = document.createElementNS(ns, "stop");
        s1.setAttributeNS(null, "offset", "100%");
        s1.setAttributeNS(null, "stop-color", "#444");
        gr.appendChild(s1);
        defs.appendChild(gr);

        poly.setAttributeNS(null, "fill", `url(#grad${cpt})`);
        cpt++;

        svg.appendChild(poly);
    };

    const coord = (id) => {
        var pt = document.getElementById(id);
        return [ Number(pt.getAttribute("cx")),
                    Number(pt.getAttribute("cy"))];
    };

    const line = (pt1, pt2) => {
        return [ pt2[1]-pt1[1], 
                    pt1[0]-pt2[0], 
                        pt2[0]*pt1[1]-pt1[0]*pt2[1] ];
     };

    const inter = (line1, line2) => {
        var denom = line1[0] * line2[1] - line1[1] * line2[0];
        return [ (line2[2] * line1[1] - line2[1] * line1[2]) / denom,
                 (line2[0] * line1[2] - line2[2] * line1[0]) / denom ];
    };

    const rotate = (pt, a) => 
        [ pt[0] * Math.cos(a) - pt[1] * Math.sin(a)
        , pt[0] * Math.sin(a) + pt[1] * Math.cos(a) ];

    const translate = (pt, v) => [pt[0] + v[0], pt[1] + v[1]];

    const dist = (pt1, pt2) => 
        Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
        
    const one = (po, pe) => {
        let v = [pe[0]-po[0], pe[1]-po[1]];
        let l = dist(v,[0,0]);
        return [v[0]/l, v[1]/l];
    };

    const vec = (pt1,pt2) => [pt2[0]-pt1[0],pt2[1]-pt1[1]];
    const sym = (ref, pt) => [ 2*ref[0]-pt[0], 2*ref[1]-pt[1] ];
    const middle = (p, q) => [(p[0]+q[0])/2,(p[1]+q[1])/2];
    
    const d = pt => [ -pt[0], pt[1] ];
    const q = pt => [ pt[0], -pt[1] ];
    const b = pt => [ -pt[0], -pt[1] ];

    const up = pt => [pt[0], pt[1] - motifHeight];
    const down = pt => [pt[0], pt[1] + motifHeight];
    const left = pt => [pt[0] - motifWidth, pt[1]];
    const right = pt => [pt[0] + motifWidth, pt[1]];

    const t = 2*Math.PI/10;
    const phi = (1+Math.sqrt(5))/2;
    const cosPi10 = Math.sqrt((phi+2))/2;
    const k = 2*cosPi10/Math.sqrt(5);
   // const h = k*phi;
   // const l = k/phi;

    //
    // GRAPHICAL CONTENT
    //

    const tg = 0; // croisement peu delicat vers la gauche
    const tD = 1; // croisement tres delicat vers la droite

    const angle = [108,36].map(a=>a*Math.PI/180);

    var radius = 39.036;
    var laceWidth = p =>  Math.min(63,dist(p,[0,0])**2 / 98000);//43 * dist(p,[0,0]) / (1 +  dist(p,[0,0]));
    var sizeX = 10;
    var sizeY = 9;

    var motifHeight = 2 * radius * k * (3*phi+2);
    var motifWidth =  2 * radius * (2*phi+1);

    //svg.setAttributeNS(null, "width", (2*sizeX)*motifWidth);
    //svg.setAttributeNS(null, "height", (2*sizeY)*motifHeight);
    svg.setAttributeNS(null, "width", 1000);
    svg.setAttributeNS(null, "height", 1000);
    svg.setAttributeNS(
        null, 
        "viewBox", 
        `-${sizeX*motifWidth} -${(sizeY+1)*motifHeight} ${2*sizeX*motifWidth} 
        ${2*(sizeY+1)*motifHeight}`);
    
    var p0 = [radius*Math.cos(0),-radius*Math.sin(0)];
    var p1 = [radius*Math.cos(t),-radius*Math.sin(t)];
    var p2 = [radius*Math.cos(2*t),-radius*Math.sin(2*t)];

    var v0 = one(p0,p2);
    var v1 = one(p1,d(p2));
    var v2 = one(p2,d(p1));
    var v3 = one(d(p2),b(p0));
    
    var b0 = [(phi+1)*radius, 0];
    var p3 = [b0[0]-k*radius*v2[0], b0[1]-k*radius*v2[1]];
    var b1 = rotate(b0,-t);
    var c0 = inter(line(p0,b1),line(p1,q(p3)));
    var q4 = rotate(p3,t);
    var p4 = q(q4);
    var e0 = [q4[0]-k*radius*v3[0], q4[1]-k*radius*v3[1]];
    var e1 = rotate(e0,-t);
    var p5 = sym(e1,p3);
    var p6 = sym(e1,q(p3));
    var p7 = rotate(p3,-t);
    var p8 = rotate(p4,-t);
    var c2 = rotate(c0,-2*t);
    var e2 = rotate(e1,-t);
    var p9 = sym(e2,c2);
    var p10 = inter(line(e0,q4),line(e1,p4));
    var p11 = sym(e1,b0);
    var p12 = sym(e2,p8);
    var p13 = rotate(p12,-t);
    var f0 = sym(e2,b1);
    var g0 = sym(f0,p13);
    var f1 = inter(line(p12,p9),line(g0,p6));
    var f2 = rotate(f1,-t);
    var e3 = rotate(e2,-t);
    var p14 = sym(f2,e3);
    var p15 = sym(e2,p2);
    var p16 = rotate(p6,-t);
    var p17 = rotate(g0,-t);
    var p18 = rotate(p7,-t);
    var p19 = sym(f0, p18);
    var p20 = rotate(p5,-t);
    var p21 = [p14[0]+phi*radius, p14[1]];
    var p22 = sym(f2,p13);
    
    var g1 = [f2[0]-k*phi**2*radius*v2[0], f2[1]-k*phi**2*radius*v2[1]];
    var b2 = rotate(b1,-t);
    var c1 = rotate(c0,-t);

    var w1 = [-k*phi*radius*v1[0], -k*phi*radius*v1[1]];

    var correction = (p, q, out) => {
        var l1,l2,l3,l4,l5,l6,l7;
        var supsup, supinf, infsup, infinf;

        l1 = line(p,q);
        l2 = [l1[0],l1[1],l1[2]+laceWidth(middle(p,q))*Math.sqrt(l1[0]**2+l1[1]**2)];
        l3 = [l1[0],l1[1],l1[2]-laceWidth(middle(p,q))*Math.sqrt(l1[0]**2+l1[1]**2)];

        l4 = line(p,out);
        l5 = [l4[0],l4[1],l4[2]+laceWidth(middle(p,q))*Math.sqrt(l4[0]**2+l4[1]**2)];
        l6 = [l4[0],l4[1],l4[2]-laceWidth(middle(p,q))*Math.sqrt(l4[0]**2+l4[1]**2)];

        supsup = inter(l2,l5);
        supinf = inter(l2,l6);
        infsup = inter(l3,l5);
        infinf = inter(l3,l6);

        l7 = line(supsup,infinf);
        if((l7[0]*q[0]+l7[1]*q[1]+l7[2])*(l7[0]*out[0]+l7[1]*out[1]+l7[2]) < 0)
            return [ supsup, infinf];
        return [ supinf, infsup ];
    };

    const mapper = (pt,m,n) => {
        let [x,y] = pt;
        [x,y] = [x+m*motifWidth, y+n*motifHeight];
        let z = cplx(x,y);
        //z = div(z,cplx(400,0));
        //z = tan(z);
        //z = mul(z,cplx(400,0));
        
        //z = exp(mul(mul(z,z),cplx(-1,0)));
        
        z=div(z,cplx(2000,0));
        z = tan(z);
        z=mul(z,cplx(1000,0));
        
        //z = add(z,cplx(0*motifWidth,-motifHeight/2));
        //z = add(cplx(1,0),mul(z,z));
        //z = mul(tan(z),cplx(radius**5,0));
        return [-z.im,z.re];
    };
    
    const pointMap = (f,x) => {
            if (x.length !== 0) {
                if(x[1].hasOwnProperty('length'))
                    return [x[0], f(x[1])];
                else return f(x);
            } else return x;
        }
    
    var thread = (m,n,j) => {

        var xs = motif[j].map(x => pointMap(y=>mapper(y,m,n),x));

        for(let i=0; i<xs.length-2; i+=2) {
            var beg = xs[i];
            var p = xs[i+1];
            var end = xs[i+2];

            var a1, a2, a3, a4;
            var a, r, v, vp, z, end1;

            if(beg.length==2) {
                [a1, a2] = correction(p, beg[1], end.length==2?end[1]:xs[i+3]);
                v = one(beg[1], p);
                a = angle[beg[0]];
                r = rotate(v, a);
                z = laceWidth(p) / Math.sin(a);
                a3 = [beg[1][0]+z*(r[0]+v[0]), beg[1][1]+z*(r[1]+v[1])];
                a4 = [beg[1][0]+z*(-r[0]+v[0]), beg[1][1]+z*(-r[1]+v[1])];
                
                polygon([a1,a4,a3,a2],j);
                /*
                segment(a1,a4,j);
                segment(a4,a3,j);
                segment(a3,a2,j);
                */
            } 

            if(end.length==2) {
                [a1, a2] = correction(p, end[1], beg.length==2?beg[1]:xs[i-1]);
                v = one(p, end[1]);
                a = angle[end[0]];
                r = rotate(v, a);
                z = laceWidth(p) / Math.sin(a);
                a3 = [end[1][0]+z*(-r[0]-v[0]), end[1][1]+z*(-r[1]-v[1])];
                a4 = [end[1][0]+z*(r[0]-v[0]), end[1][1]+z*(r[1]-v[1])];
                
                polygon([a1,a4,a3,a2],j);
                /*
                segment(a1,a4,j);
                segment(a4,a3,j);
                segment(a3,a2,j);
                */

            } else {
                end1 = xs[i+3];
                v = one(p, end1);
                vp = [v[1], -v[0]];
                a1 = [p[0]-laceWidth*vp[0], p[1]-laceWidth*vp[1]];
                a2 = [p[0]+laceWidth*vp[0], p[1]+laceWidth*vp[1]];
                if(beg.length==2) [a1, a2] = correction(p, end1, beg[1]);
                [a3, a4] = correction(end1, p, xs[i+4][1]);
                
                polygon([a1,a4,a3,a2],j);
                /*
                segment(a1,a4,j);
                segment(a3,a2,j);
                */
            }
        }
    };

    var threads = () => Array.from({length: motif.length}, 
        (_,i)=>i).forEach(xs => {
            for(let m=-sizeX; m<sizeX; m++)
                for(let n=-sizeY; n<sizeY; n++)
                    thread(m,n,xs);
        });
        
    var epsilon = pt => [pt[0]+0.01,pt[1]];
    var complete = arr => 
        arr.map(x =>
            pointMap(y => 
                translate(y,vec( arr[0][1], arr[arr.length-1][1] || arr[arr.length-3][1] )),x));
   
    var motif0 = [[tD, up(b(f0))], d(p21), [tg, d(g1)], d(p20), [tD, d(e2)], d(p7), [tg, d(c0)],
         d(p0), [tD, b(b1)], b(p7), [], b(p20), [tD, b(f0)], b(p21), [tg, down(d(g1))]];
    
    var motif2 = [[tg, d(p10)], d(p4), [tD, d(b1)], d(p2), [tg, c2], p8, [tD, e2], p12, 
        [tg, p9], right(d(p15)), [tD, right(d(f0))], right(d(p16)), [tg, right(d(p17))]];

    var motif4 = [[tD, d(f1)], d(p12), [], d(p8), [tD, d(b2)], p2, [tg, c1], p4, 
        [tD, e1], translate(epsilon(p10), v0), [tD, right(d(e0))], right(b(p4)), 
        [tg, right(b(c1))], right(b(p2)), [tD, right(q(b2))] ];
 
    var motif6 = [[tD, b(p11)], b(p5), [], b(p3), [tD, b(b0)], d(p1), [tg, d(c1)], 
        d(p18), [tD, e3], p13, [], p22, [tD, p14], up(q(p19)), [tg, up(q(g0))], up(q(p6)), 
        [tD, up(q(p11))]];
    
    var motif8 = [[tg, up(left(q(p5)))], up(b(p6)), [tD, up(b(f1))], 
        up(b(p19)), [tg, up(b(g1))], d(p22), [tD, d(f2)], d(p13), [], p18, 
        [tD, b2], p1, [tg, c0], q(p3), [tD, q(e1)], q(p5), [tg, translate(q(p5),w1)]]; 
         
    var motif = [   
        motif0, motif0.map(x=>pointMap(y=>b(y),x)),
        motif2, complete(motif2), 
        motif4, complete(motif4),
        motif6, motif6.map(x=>pointMap(y=>b(y),x)),
        motif8, motif8.map(x=>pointMap(y=>b(y),x))
     ];

    threads();
    
    ]]></script>
 </svg> 
