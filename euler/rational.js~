
let gcd = (a, b) => a > b ? gcd(b,a) : (a==0n ? b : gcd(b%a,a));
let abs = a => a < 0n ? -a : a;
let sign = a => a < 0n ? -1n : 1n;
let increasing = (a, b) => {
    if(a > b) {
        return 1;
    } else if (a < b){
        return -1;
    } else {
        return 0;
    }
};

let sqrt = function (a) {

    let iter = x => (x + a / x) / 2n;

    var b, c = a;
    do {
        b = c;
        c = iter(b);
    } while(c < b);
    return b;
};

class EgyptianSolver {
    u;
    t;
    n;
    list;
    running;
    div;
    vars;

    constructor(n,t) {
        this.u = Array.from({length: t-1}, (_,__) => 1n);
        this.u[0]=3n;
        this.div = Array.from({length: t});
        this.vars = Array.from({length: t});
        this.t = t;
        this.n = n;
        this.list = [];
        this.running = t-2;
    }

    done() {
        return this.u[0] > BigInt(this.t - 1) *  this.n; 
    }

    solutions() {
        return this.list;
    }

    progress() {
        var h, hu, q, mul, deno, cpt;
        this.vars[0] = this.n + this.u[0];
        cpt = 1;
        this.div[0] = this.n;
        mul = 1n;

        for (let i=0; i<this.t-1; i++) {
            mul *= this.u[i];
            deno = this.div[i] + this.u[i];
            h = this.div[i] * deno;
            this.div[i+1] = h;
            hu = h + (i == this.t-2 ? 0n : this.u[i+1]);
            q = hu / mul;
            if (hu % mul != 0n || q <= this.vars[i]) continue;
            this.vars[cpt] = q;
            cpt++;
        }
        if(this.running>=0 
            && this.u[this.running] 
                <= BigInt(this.t-1-this.running) * this.div[this.running]) {
            if(cpt == this.t) {
                this.list.push([...this.vars]);
                console.log(this.vars);
            }
        }
        else {
            while(this.running>0 
                && this.u[this.running] 
                    > BigInt(this.t-1-this.running) * this.div[this.running]) 
                this.running--;
            this.u[this.running]++;
            for (let i = this.running+1; i < this.t-1; i++) this.u[i] = 1n;
            this.running = this.t-2;
            this.u[this.running]--;
        }
        this.u[this.running]++;
    }
}

class Rational {
    numerator;
    denominator;

    constructor(x,y) {
        this.numerator = x;
        this.denominator = y;
    }

    normalize() {
        if (this.denominator < 0n) {
            this.numerator *= -1n;
            this.denominator *= -1n;
        }
        let g = gcd(abs(this.numerator), this.denominator);
        this.numerator /= g;
        this.denominator /= g;
    }

    add(that) {
        let q = new Rational(
            this.numerator * that.denominator 
                + this.denominator * that.numerator,
            this.denominator * that.denominator);
        q.normalize();
        return q;
    }

    sub(that) {
        let q = new Rational(
            this.numerator * that.denominator 
                - this.denominator * that.numerator,
            this.denominator * that.denominator);
        q.normalize();
        return q;
    }

    mul(that) {
        let q = new Rational(this.numerator * that.numerator,
                             this.denominator * that.denominator);
        q.normalize();
        return q;
    }

    inv() {
        let q = new Rational(this.denominator, this.numerator);
        q.normalize();
        return q;
    }

    div(that) {
        return this.mul(that.inv());
    }

    sqrt() {
        return new Rational (sqrt(this.numerator), sqrt(this.denominator));
    }

    // fraction m/n as sum of t natural inverses
    egyptian(t) {
        let m = this.numerator;
        let n = this.denominator;

        // first : find the t-terms sums of 1/n
        let solver = new EgyptianSolver(n,t);
        while (!solver.done()) solver.progress();
        let sums = solver.solutions();

        // then : divide by m those which can be
        return sums
            .filter(arr => arr.every(x => x%m == 0n && x != m))
            .map(arr => arr.map(x => x/m));
    }
}
